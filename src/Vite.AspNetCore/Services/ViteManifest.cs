// Copyright (c) 2023 Quetzal Rivera.
// Licensed under the MIT License, See LICENCE in the project root for license information.

using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using System.Text.Json;
using Vite.AspNetCore.Abstractions;

namespace Vite.AspNetCore.Services
{
	/// <summary>
	/// This class is used to read the manifest.json file generated by Vite.
	/// </summary>
	public sealed class ViteManifest : IViteManifest
	{
		private readonly IReadOnlyDictionary<string, ViteChunk> _chunks;

		/// <summary>
		/// Initializes a new instance of the <see cref="ViteManifest"/> class.
		/// </summary>
		public ViteManifest(IConfiguration configuration, IWebHostEnvironment environment)
		{
			// Read tha name of the manifest file from the configuration.
			var manifest = configuration["Vite:Manifest"] ?? "manifest.json";

			// Get the manifest.json file path
			var manifestPath = Path.Combine(environment.WebRootPath, manifest);

			// Check if the manifest.json file exists. If it doesn't, set the chunks to empty.
			if (!File.Exists(manifestPath))
			{
				this._chunks = new Dictionary<string, ViteChunk>();
			}
			else
			{
				// Read the manifest.json file and deserialize it into a dictionary
				this._chunks = JsonSerializer.Deserialize<IReadOnlyDictionary<string, ViteChunk>>(File.ReadAllBytes(manifestPath), new JsonSerializerOptions()
				{
					PropertyNameCaseInsensitive = true,
				})!;
			}
		}

		/// <summary>
		/// Gets the Vite chunk for the specified entry point if it exists.
		/// If Dev Server is enabled, this will always return <see langword="null"/>.
		/// </summary>
		/// <param name="key"></param>
		/// <returns>The chunk if it exists, otherwise <see langword="null"/>.</returns>
		public IViteChunk? this[string key] => this._chunks.TryGetValue(key, out var chunk) ? chunk : null;
	}
}
